var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Nmrc.Incident","page":"API","title":"Nmrc.Incident","text":"Incident\n\nSome parameters related to the incident field.\n\nParameters\n\nk: the wave number\nθ: the incident field\nα: α = k * sin(θ)\nβ: β = k * cos(θ)\n\n\n\n\n\n","category":"type"},{"location":"api/#Nmrc.Incident-Tuple{Float64, Float64}","page":"API","title":"Nmrc.Incident","text":"Incident(k::Float64, θ::Float64)\n\nDefine the incident field with the wavenumber k and the incident field θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.PML","page":"API","title":"Nmrc.PML","text":"Pml\n\nInformation on PML layer and coordinate transformation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Nmrc.allocate_matrices-Tuple{Ferrite.DofHandler, Ferrite.ConstraintHandler}","page":"API","title":"Nmrc.allocate_matrices","text":"allocate_matrices(dof::DofHandler, cst::ConstraintHandler)\n\nAllocate the complex-valued stiffness matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.allocate_stiff_matrix-Tuple{Ferrite.DofHandler, Ferrite.ConstraintHandler, Any}","page":"API","title":"Nmrc.allocate_stiff_matrix","text":"allocate_stiff_matrix(dofhandler::DofHandler, csthandler::ConstraintHandler, dofs)\n\nCreate a sparse pattern for the stiffness matrix. We need to add extra entries  due to the DtN map by hand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.apply_all_bds!-Tuple{Union{LinearAlgebra.Symmetric, SparseArrays.SparseMatrixCSC}, Ferrite.ConstraintHandler}","page":"API","title":"Nmrc.apply_all_bds!","text":"apply_all_bds!(K::Union{SparseMatrixCSC, Symmetric}, ch::ConstraintHandler)\napply_all_bds!(KK::Union{SparseMatrixCSC, Symmetric}, f::AbstractVector, ch::ConstraintHandler, applyzero::Bool = false)\n\nImpose the periodic boundary condition and the Dirichlet boundary condition on the matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.assemble_A-Tuple{Ferrite.CellValues, Ferrite.DofHandler, SparseArrays.SparseMatrixCSC, Incident}","page":"API","title":"Nmrc.assemble_A","text":"assemble_A(cv::CellValues, dh::DofHandler, A::SparseMatrixCSC, inc::Incident)\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.assemble_A0-Tuple{Ferrite.CellValues, Ferrite.DofHandler, SparseArrays.SparseMatrixCSC, Function, PML, Any}","page":"API","title":"Nmrc.assemble_A0","text":"assemble_A0(cv, dh, A₀, medium, p, k)\n\nAssemble the zero order term in the quadratic eigenvalue problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.assemble_A1-Tuple{Ferrite.CellValues, Ferrite.DofHandler, SparseArrays.SparseMatrixCSC, PML}","page":"API","title":"Nmrc.assemble_A1","text":"assemble_A1(cv::CellValues, dh::DofHandler, A₁::SparseMatrixCSC, p::PML)\n\nAssemble the first order term in the quadratic eigenvalue problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.assemble_A2-Tuple{Ferrite.CellValues, Ferrite.DofHandler, SparseArrays.SparseMatrixCSC, PML}","page":"API","title":"Nmrc.assemble_A2","text":"assemble_A2(cv::CellValues, dh::DofHandler, A₂::SparseMatrixCSC, p::PML)\n\nAssemble the second order term in the quadratic eigenvalue problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.assemble_load-Tuple{Ferrite.FacetValues, Ferrite.DofHandler, Any, Any, Incident, Any}","page":"API","title":"Nmrc.assemble_load","text":"assemble_load(fv::FacetValues, dh::DofHandler, facetset, f, inc::Incident, height)\n\nAssemble the load vector due to the incident field.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.assemble_tbc-Tuple{Ferrite.FacetValues, Ferrite.DofHandler, Incident, Vararg{Any, 4}}","page":"API","title":"Nmrc.assemble_tbc","text":"assemble_tbc(fv::FacetValues, dh::DofHandler, inc::Incident, F::SparseMatrixCSC, facetset, N, dofsDtN)\n\nAssemble the TBC matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.beta_n-Tuple{Incident, Any}","page":"API","title":"Nmrc.beta_n","text":"beta_n(inc::Incident, n)\n\nCompute the βₙ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.compute_coef!-Tuple{Ferrite.FacetValues, Ferrite.DofHandler, Any, SparseArrays.SparseVector, Any}","page":"API","title":"Nmrc.compute_coef!","text":"compute_coef!(fv::FacetValues, dh::DofHandler, θ::SparseVector, facetset, n)\n\nCompute Θⁿ on the facetset. Actually the computation of the TBC matrix reduces  to the computation of the vector Θⁿ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.compute_scaling-Union{Tuple{M}, Tuple{T}, Tuple{M, M, M}} where {T, M<:AbstractMatrix{T}}","page":"API","title":"Nmrc.compute_scaling","text":"compute_scaling(A₀::M, A₁::M, A₂::M; scaling=:nothing::Symbol) where {T,M<:AbstractMatrix{T}}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.coord_transform-Tuple{Any, PML}","page":"API","title":"Nmrc.coord_transform","text":"coord_transform(x₂, p::PML)\n\nCoordinate transformation of PML method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.dofs_on_dtn-Tuple{Ferrite.DofHandler, Symbol, Any}","page":"API","title":"Nmrc.dofs_on_dtn","text":"dofs_on_dtn(dh::DofHandler, field::Symbol, facetset)\n\nExtract the global indices of Dofs associated to the artificial boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.get_width-Tuple{PML}","page":"API","title":"Nmrc.get_width","text":"get_width(p::PML)\n\nGet the width of the PML layer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.periodic_cell-Tuple{}","page":"API","title":"Nmrc.periodic_cell","text":"periodic_cell(;lc=0.5, period=2π, height=2.0)\n\nGenerate a mesh for the periodic cell.\n\nArguments\n\nlc: the mesh size near points\nperiod: the period of the periodic cell\nheight: the height of the periodic cell\n\nPoints\n\n 4 ------------ 3\n |              |\n |              |\n 1 ------------ 2\n\nLines\n\n . ---- l3 ---- .\n l4             l2\n . ---- l1 ---- .\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.setup_bcs-Tuple{Ferrite.DofHandler}","page":"API","title":"Nmrc.setup_bcs","text":"setup_bcs(dh::DofHandler; period=2π)\n\nSet the periodic boundary condition (\"left\" and \"right\") and  Dirichelt boundary condition (\"bottom\").\n\nArguments\n\ndh: DofHandler\nperiod: the period of the periodic cell, see periodic_cell\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.setup_bdcs-Tuple{Ferrite.DofHandler, Any}","page":"API","title":"Nmrc.setup_bdcs","text":"setup_bdcs(dof::DofHandler, d)\n\nSet the periodic boundary condition (\"left\" and \"right\") and  Dirichelt boundary condition (\"bottom\" and \"top\").\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.setup_dofs-Tuple{Ferrite.Grid, Any}","page":"API","title":"Nmrc.setup_dofs","text":"setup_dofs(grid::Grid, ip)\n\nSetup degree of freedoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.setup_fevs-Tuple{Any}","page":"API","title":"Nmrc.setup_fevs","text":"setup_fevs(ip)\n\nDefine quadrature rules on Reference triangle and setup FE values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.setup_grid-Tuple{}","page":"API","title":"Nmrc.setup_grid","text":"setup_grid(;d=2π, ĥ=1.5, δ=2.0, lc=0.5, lp=0.5, vtk=false)\n\nGenerate a mesh by julia interface for Gmsh and read the .msh file by FerriteGmsh.\n\nArguments\n\nd: the period of the periodic layer\nĥ: the start of the PML layer\nδ: the height of the PML layer\nlc: mesh size near the periodic layer\nlp: mesh size in the PML layer\nvtk: write .vtk file, default is false\n\nPoints\n\n 5 ------------- 4\n |               |\n 6               3\n |               |\n 1 ------------- 2\n\nLines\n\n . ----- l4 ----- . \n l5               l3\n .                .\n l6               l2 \n . ----- l1 ----- .\n\nMisc\n\nWe can generate a *.vtk file by replace the do end block with gmsh.write(*.vtk)\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.setup_vals-Tuple{Any}","page":"API","title":"Nmrc.setup_vals","text":"setup_vals(ip)\n\nSet up CellValues and FacetValues by using interpolation ip. Here we need  to define FacetValues because the load vector and the TBC matrix contains  integral on the boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Nmrc.sub_preserve_structure-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"API","title":"Nmrc.sub_preserve_structure","text":"sub_preserve_structure(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nSubtract two sparse matrix without changing the sparse pattern. A and B  should have the same sparse pattern.\n\n\n\n\n\n","category":"method"},{"location":"fem_dtn/#Finite-Element-Method-with-Transparent-Boundary-Condition","page":"FEM-DtN","title":"Finite Element Method with Transparent Boundary Condition","text":"","category":"section"},{"location":"fem_dtn/","page":"FEM-DtN","title":"FEM-DtN","text":"To handle unbounded computational domains, we introduce Dirichlet-to-Neumann  map (DtN) which maps the Dirichlet value to the Neumann value of the solution  of a boundary value problem. In our problem, we construct the DtN map based on  the Rayleigh expansion radiation conditon. Then the DtN map give rise to a transparent  boundary conditon on the artificial boundary which truncates the unbounded domain.","category":"page"},{"location":"fem_dtn/#DtN-map-and-transparent-boundary-condition","page":"FEM-DtN","title":"DtN map and transparent boundary condition","text":"","category":"section"},{"location":"fem_dtn/#Finite-element-discretization","page":"FEM-DtN","title":"Finite element discretization","text":"","category":"section"},{"location":"flat/#Finite-element-method-with-transparent-boundary-condition","page":"Tutorials","title":"Finite element method with transparent boundary condition","text":"","category":"section"},{"location":"flat/#Introduction","page":"Tutorials","title":"Introduction","text":"","category":"section"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"Consider a flat surface illuminated by a plane wave. The incident field is given by","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"u^textin = e^ialpha x_1 - ibeta x_2","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"where alpha = ksintheta beta = kcostheta; k  0 is the wave number, and theta in (-pi2 pi2) is the incident angle. We assume that the total field u = u^textin + u^textsc, composed of the incident field u^textin and the scattered field u^textsc, satisfies the Dirichelt boundary condition on the bottom x_2 = 0.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"Due to the periodic structure and incident plane wave, we can work on periodic function space, that is, v = e^-ialpha x_1u. So the exact solution is v_textexact = -2isin(beta x_2).","category":"page"},{"location":"flat/#Numerical-examples","page":"Tutorials","title":"Numerical examples","text":"","category":"section"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"First, we load Nmrc and Ferrite (Ferrite is used to define the interpolation).","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"using Nmrc, Ferrite","category":"page"},{"location":"flat/#Parameters","page":"Tutorials","title":"Parameters","text":"","category":"section"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"We assume that the wavenumber is 10 and the incident angle is pi3.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"# incident plane wave\nk = 1.0\nθ = π/3\ninc = Incident(k, θ)\n\n# Number of the truncated terms\nN = 10;\n\n# Height of the artificial boundary\nheight = 2.0;\nnothing #hide","category":"page"},{"location":"flat/#Generating-a-mesh-by-Gmsh","page":"Tutorials","title":"Generating a mesh by Gmsh","text":"","category":"section"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"We generate a mesh on a periodic cell which is a rectangle (00 2pi) times (00 20).","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"# Generate the mesh in a periodic cell\ngrid = periodic_cell(lc=0.1, period=2π, height=height)","category":"page"},{"location":"flat/#Setting-up-finite-element-space-and-boundary-conditions","page":"Tutorials","title":"Setting up finite element space and boundary conditions","text":"","category":"section"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"We choose P1 element here. Then CellValues and FacetValues can be constructed by the function setup_vals.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"ip = Lagrange{RefTriangle, 1}()\ncv, fv = setup_vals(ip)","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"DofHandler handles numbering and distribution of degrees of freedom (dofs) of our solution.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"dh = setup_dh(grid, ip)","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"We use setup_bcs to construct our ConstraintHandler which contains the information of the boundary conditions. In this tutorial, we impose the Dirichelt boundary condition on the lower boundary and the periodic boundary condition on the left and right boundaries.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"cst = setup_bcs(dh; period=2π)","category":"page"},{"location":"flat/#Assembling-the-stiffness-matrix","page":"Tutorials","title":"Assembling the stiffness matrix","text":"","category":"section"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"We allocate the stiffness matrix A, the TBC matrix F and the load vector f. Due to the DtN map, we need to extract the dofs associated to the artificial boundary.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"# Extract dofs on the \"top\" boundary\ntop = getfacetset(grid, \"top\")\ndofsDtN = dofs_on_dtn(dh, :u, top)","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"Then we create the sparse pattern of A and F. For more details, please refer to allocate_stiff_matrix.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"# Allocate the stiffness matrix and the load vector\nA = allocate_stiff_matrix(dh, cst, dofsDtN)\nF = allocate_stiff_matrix(dh, cst, dofsDtN)\nf = zeros(ComplexF64, ndofs(dh));\n\n# Assemble the load vector f\nf = assemble_load(fv, dh, top, f, inc, height)\n\n# Assemble the matrix A\nA = assemble_A(cv, dh, A, inc)\n\n# Assemble the TBC matrix\nF = assemble_tbc(fv, dh, inc, top, F, N, dofsDtN)","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"Be careful! Calculations between two sparse matrices may destory the structure of sparse matrices. Then imposing the boundary condition may fail. So we use sub_preserve_structure to subtract F from A with keeping the structure of A.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"# Add the TBC matrix to A = A - F\nA = sub_preserve_structure(A, F)\n\n# Impose the boundary condition\napply!(A, f, cst)\n\n# Solve the linear system\nu = A\\f\n\n# Apply the boundary condition again\napply!(u, cst)","category":"page"},{"location":"flat/#Export-the-VTK","page":"Tutorials","title":"Export the VTK","text":"","category":"section"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"Finally, we write the real part and imaginary part of the solution into vtk files which can be visualized by Paraview.","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"VTKGridFile(\"real_u\", grid) do vtk\n   write_solution(vtk, dh, real.(u))\nend;\n\nVTKGridFile(\"imag_u\", grid) do vtk\n    write_solution(vtk, dh, imag.(u))\nend;\nnothing #hide","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"flat/","page":"Tutorials","title":"Tutorials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fem_pml/#Finite-Element-Method-with-Perfectly-Matched-Layer","page":"FEM-PML","title":"Finite Element Method with Perfectly Matched Layer","text":"","category":"section"},{"location":"fem_pml/#Perfectly-matched-layer-(PML)","page":"FEM-PML","title":"Perfectly matched layer (PML)","text":"","category":"section"},{"location":"fem_pml/#Finite-element-discretization","page":"FEM-PML","title":"Finite element discretization","text":"","category":"section"},{"location":"#Nmrc","page":"Home","title":"Nmrc","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Nmrc.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nmrc.jl can be installed by opening a Julia REPL and typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/peakfind/Nmrc.jl.git","category":"page"},{"location":"#Methods-Implemented-in-Nmrc.jl","page":"Home","title":"Methods Implemented in Nmrc.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use PML and FEM to estimate the exceptional values (quasi momentum).\nFEM with transparent boundary condition (DtN map).","category":"page"},{"location":"#TBD","page":"Home","title":"TBD","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High order quadrature rules on facets may change the sparse pattern of the vector Theta^n.","category":"page"}]
}
